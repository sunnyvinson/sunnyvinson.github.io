<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Java之IO流整理]]></title>
      <url>%2F2017%2F02%2F28%2FJava%E4%B9%8BIO%E6%B5%81%E6%95%B4%E7%90%86%2F</url>
      <content type="text"><![CDATA[一、IO流的划分Java中的流，可以从不同的角度进行分类,具体如下： 按照数据流的方向不同可以分为：输入流和输出流。 按照处理数据单位不同可以分为：字节流和字符流。 按照实现功能不同可以分为：节点流和处理流。 1、输入流输出流示意图： 2、字符流字节流字节流：一次读入或读出是8位二进制(即1个字节)。字符流：一次读入或读出是16位二进制(即2个字节)。 2.1文件存储到磁盘的过程简述所有文件的存储都是以二进制（即byte）的形式存储的，在磁盘保存的并不是字符而是先把字符编码成字节，然后存储到磁盘中。在读取文件时，也是一个字节一个字节地读取以形成字节序列。 2.2字符流和字节流的比较(1)处理的数据单位：字节流：一次读入或读出是8位二进制(即1个字节)。字符流：一次读入或读出是16位二进制(即2个字节)。 (2) 操作的对象：字节流：可以操作一切文件（原因：所有文件都是以二进制存储在内存中的），包括操作图像、音频、歌曲等等字符流：操作字符、字符数组、字符串，这些纯文本。 (3)操作文件的方式：字节流直接操作文件。字符流是通过缓存区操作文件的。注意，使用了各自的输出流对象而没有关闭时，字节流能够输出到文件上，字符流不行，如果要输出就使用flush()。另外在关闭输出流对象时，两者都会强制输出。 (4)后缀辨别：后缀是Stream的是字节流。后缀是Reader，Writer的是字符流。 3、节点流处理流节点流：直接与数据源相连，读入或读出。直接使用节点流，读写不方便，为了更快的读写文件，才有了处理流。处理流：与节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。 二、IO流的四大基类InputStream(字节输入流)、OutputStream（字节输出流）、Reader（字符输入流）、Writer（字符输出流）。 字节输入流 字节输出流 字符输入流 字符输出流 简述不同流的适用场景(1)对文件进行操作：FileInputStream（字节输入流），FileOutputStream（字节输出流），FileReader（字符输入流），FileWriter（字符输出流） (2)对管道进行操作：PipedInputStream（字节输入流）,PipedOutStream（字节输出流），PipedReader（字符输入流），PipedWriter（字符输出流） (3)对字节或者字符数进行操作：ByteArrayInputStream，ByteArrayOutputStream，CharArrayReader，CharArrayWriter是在内存中开辟了一个字节或字符数组。 (4) Buffered缓冲流：BufferedInputStream，BufferedOutputStream，BufferedReader，BufferedWriter,是带缓冲区的处理流，缓冲区的作用的主要目的是：避免每次和硬盘打交道，提高数据访问的效率。 注意：StringBufferInputStream这个缓冲流已经过时，此类未能正确地将字符转换为字节。从 JDK 1.1 开始，从字符串创建流的首选方法是通过 StringReader 类进行创建。 (5) 转化流：InputStreamReader/OutputStreamWriter，把字节转化成字符,创建时传入的参数类型是InputStream/OutputStream（字节流）。 (6) 数据流：DataInputStream，DataOutputStream。因为平时若是我们输出一个8个字节的long类型或4个字节的float类型，那怎么办呢？可以一个字节一个字节输出，也可以把转换成字符串输出，但是这样转换费时间，若是直接输出该多好啊，因此这个数据流就解决了我们输出数据类型的困难。数据流可以直接输出float类型或long类型，提高了数据读写的效率。 (7) 对象流：ObjectInputStream，ObjectOutputStream，把封装的对象直接输出，而不是一个个在转换成字符串再输出 (8) 序列化流：SequenceInputStream。 (9) 对象序列化把对象直接转换成二进制，写入介质中。使用对象流需要实现Serializable接口，否则会报错。而若用transient关键字修饰成员变量，不写入该成员变量，若是引用类型的成员变量为null，值类型的成员变量为0. (10) 打印流：printStream，printWriter。一般是打印到控制台，可以进行控制打印的地方。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MyBatis原理简述]]></title>
      <url>%2F2016%2F03%2F28%2FMyBatis%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0%2F</url>
      <content type="text"><![CDATA[API介绍MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 主要特征MyBatis中接口中的方法和命名空间的sql语句绑定。可以称为面向接口编程，也是其核心。 运行原理简述概括：Mybatis通过xml或注解的方式将要执行的statement配置起来，并通过Java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。1、mybatis配置Configuration.xml，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。mapper.xml文件即sql映射文件，可以用别名配置多个。文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载使用2、 通过Mybatis环境等配置信息构造SqlSessionFactory即会话工厂。3、 由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行。4、getMapper(接口.class)，找到对应的命名空间。创建接口对象。5、sql映射文件的SQL语句对应接口的方法，当接口对象调用相应的方法时，就会执行相应的sql语句。6、将Java对象映射成相应的记录。7、事务提交。8、关闭SqlSession。 一些说明1、 mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。2、 Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。3、 Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过 Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。4、Statement对象用于执行不带参数的简单SQL语句。Statement对象用 Connection的方法createStatement创建。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java之JVM探索]]></title>
      <url>%2F2016%2F03%2F03%2FJava%E4%B9%8BJVM%E6%8E%A2%E7%B4%A2%2F</url>
      <content type="text"><![CDATA[前言：Java是一种技术，由四方面组成：Java编程语言、Java类文件格式、Java虚拟机和Java应用程序接口(Java API)，本文章对JVM虚拟机(JVM)做一个概括性的总结，以便需要之时可以查阅。 （一）JVM的组成* Class Loader SubSystem (类加载器)* Runtime Data Areas (运行时数据区)* Execution Engine (执行引擎) （二）简述各部分的作用Class Loader SubSystem装载.class字节码到Java 虚拟机中，读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。通过此实例的 newInstance()方法就可以创建出该类的一个对象。类装载器的组成：（1）引导类加载器（bootstrap class loader）：用来加载 Java 的核心库。（2）扩展类加载器（extensions class loader）：用来加载 Java 的扩展库。（3）系统类加载器（system class loader）：根据Java应用的类路径（CLASSPATH）来加载Java 类。一般来说，Java应用的类都是由它来完成加载的。 Runtime Data Areas运行时数据区指JVM在运行期间，其对计算机内存空间的划分和分配。运行时数据区组成有：（1）Method Area：方法区（主要有运行时常量池、类型信息、字段信息、方法信息、类变量，指向class实例的引用。存储已被虚拟机加载的类信息、常量、静态变量，即编译器变异后的代码等数据）（2）heap：堆,用来保存对象的实例（3）Stack Area：虚拟机栈（为每个运行的Java方法创建一个栈帧，来存储局部变量表、操作栈、动态链接、方法出口、返回值等）（4）PC：指令计数器（5）Native Method Stack：本地方法栈（调用本地方法时创建，和VM stack相似） Execution Engine执行字节码，或者执行本地方法。 （三）Jvm生命周期产生：启动一个Java程序，jvm实例就产生了。运行：main()是起点。 注意：Java虚拟机内部分守护线程和非守护线。守护线程是为其他线程服务的，必须等到其他线程全部撤离，它才会消亡。消亡：所有非守护线程终止了，Jvm退出。System.exit(). （四）GC回收机制1、基本垃圾回收算法按照基本回收的算法分引用计数、标记-清除、复制（两块区域，复制正在使用的对象到另一边）、标记-整理（集合前两种优点：第一阶段开始标记所有被引用的对象，第二阶段遍历整个堆，清除未标记对象并将存活对象“压缩”到堆的其中一块，顺序排放） 按照分区对待的方式分增量收集、分代收集 按照系统线程分串行收集器、并行收集器、（CMS并发标记清理收集器） 2、自动内存回收机制回收对象有：简单地说：不再使用的对象，即没有了引用的对象。具体地说：（1）、 超出作用域或者引用计数器为空的对象（2）、 从gc root开始搜索，搜索不到的对象（注意相关的强引用、弱引用、软引用、幻影引用区别等等）（3）、 经过一次标记-清理，仍然存活的对象 机制主要有：(1)引用计数收集器(2)跟踪收集器（使用卡片表计算法实现）(3)卡片标记算法（将老年代按照某个字节大小划分成不同区域，这个区域称为卡片。Jvm使用卡表维护卡片的状态。使用对象的引用和释放对象的引用，相应修改卡表中卡片的状态。每次minorGC只需扫描卡表中标志位脏态的对象。） 3、创建对象申请内存的过程Java创建对象的实例时，申请内存空间的过程大致会如下：（1）. JVM会试图为相关Java对象在新生代的Eden区中初始化一块内存区域。（2）. 当Eden区空间足够时，内存申请结束。否则执行下一步。（3）. JVM试图释放在Eden区中所有不活跃的对象（Young GC）。释放后若Eden空间仍然不足以放入新对象，JVM则试图将部分Eden区中活跃对象放入Survivor区。（4）. Survivor区被用来作为Eden区及老年代的中间交换区域。当老年代空间足够时，Survivor区中存活了一定次数的对象会被移到老年代。（5）. 当老年代空间不够时，JVM会在老年代进行完全的垃圾回收（Full GC）。（6）. Full GC后，若Survivor区及老年代仍然无法存放从Eden区复制过来的对象，则会导致JVM无法在Eden区为新生成的对象申请内存，即出现“Out of Memory”。 示意图如下：默认情况下内存分配 Eden:Survivor 区为8:1JVM中共划分了三个代：新生代（Young Generation）、老年代（Old Generation）和持久代（Permanent Generation）。其中持久代主要存放的是java类的类信息，与垃圾收集要收集的java对象关系不大。新生代和老年代的划分是对垃圾收集影响比较大的。 新生代：所有新生成的对象首先都是放在新生代的。新生代的目标就是尽可能快速的收集掉那些生命周期短的对象。新生代分为三个区。一个Eden区，两个Survivor区（一般而言）。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区满时，此区的存活将被复制到另外一个Survivor区，当这个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“老年代（Tenured）”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来的对象和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor区过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在新生代中的存在时间，减少被放到老年代的可能。 老年代：在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到老年代中。因此，可以认为老年代中存放的都是一些生命周期较长的对象。 持久代：用于存放静态文件，如java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class,例如Hibernate等，在这种时候需要设置一个比较大的持久空间来存放这些运行过程中新增的类。持久代大小通过 -XX:MaxPermSize = 进行设置。 4、GC的分类1、对新生代的对象的收集称为 minor GC2、对老年代的对象的收集称为 Major GC3、程序中主动调用System.gc()强制执行的GC为 Full GC与之相对的回收算法如下：新生代垃圾回收 – 标记-复制算法老年代垃圾回收 – 标记-清除或者标记-整理触发full GC的情况有四种：老年代空间不足、永久代空间满、CMS出现promotion failed和concurrent mode failure 、统计得到的minor GC级升到老年代的平均大小大于剩下的空间时 5、一道常见题目GC在什么时候、对什么东西，做了什么事情？时间： 程序员不能控制具体的时间。系统在不可预测的时间调用system.gc()函数。 Eden区满了触发minor GC。 当触发minor GC时，又有对象从survivor区升级到老年区，由于老年区剩余空间不足，触发major GC。 触发full GC的情况有四种： 1 老年代空间不足（升到老年代的对象大于老年代剩余的空间触发full GC）。 2 永久代空间不足时。 3 CMS出现promotion failed和concurrent mode failure 。 4 统计得到的minor GC级升到老年代的平均大小大于剩下的空间时，用NewRatio控制NewObject和OldObject的比例，用MaxTenuring控制进入OldObject的次数，使用OldObject存储空间延迟达到full gc，从而使得计时器引发gc时间延迟OOM的延迟，以延长对象生存期。 何物：1、 超出作用域或者引用计数器为空的对象。2、 从gc root开始搜索，搜索不到的对象（注意相关的强引用、弱引用、软引用、幻影引用区别等等）。3、 经过一次标记-清理，仍然存活的对象。 做了什么：1、 删除不使用的对象，回收内存空间。2、 运行默认的finalize()，想立刻调用，就用depose以释放资源如文件句柄，JVM用from survivor、to survivor对他进行标记清理，对象序列化之后也可以使它复活。3、 每次minor GC、major GC、full GC时，对象的复制、清理、各种回收机制的优缺点minor GC时，Eden区为新生对象分配空间，如果空间不满会清除非存活对象，将还存活的对象移到survivor区，并整理。Major GC时，老年代的垃圾回收算发取决于JVM采用的是什么垃圾回收器，扫描老年代对象，删除没有使用的对象。full GC时，除了System.gc()之外，还有四种情况会触发full gc，需要对这四种情况进行更深入的理解。 6、内存溢出与内存泄漏内存溢出Out of Memory（OOM）要求分配的Java虚拟机的内存超过了系统所能提供的大小，内存不够产生溢出。 内存泄漏Memory leak程序中动态分配了内存，但是在程序结束时，已经没有引用指向这个内存代表的对象，GC没有回收这块内存，这块空间处在一种游离的状态。重启电脑可以解决，但是仍有可能再次出现内存泄漏，这是软件设计缺陷引起的。 内存泄漏、溢出的异同？同： 都会导致应用程序运行出现问题，性能下降或挂起。异：(1) 内存泄漏是导致内存溢出的原因之一；内存泄露积累起来将导致内存溢出。(2) 内存泄漏可以通过完善代码来避免；内存溢出可以通过调整配置来减少发生频率，但无法彻底避免。 如何应对内存泄漏、溢出：（1）尽早释放无用的对象引用，比如将引用设置为null（2）程序进行字符串处理时，尽量避免使用String，而应使用StringBuffer。（3）尽量少用静态变量。（4）避免集中创建对象，比如创建大对象，或者循环创建很多对象。（5）尽量运用对象池技术，以提高性能。（6）不要经常调用某个方法区创建对象，可适当使用hashtable、vector创建一组对象容器，使用时去容器里面取出对象使用，而不是每次都去new。（7）优化配置。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java之static关键字]]></title>
      <url>%2F2016%2F02%2F27%2FJava%E4%B9%8Bstatic%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
      <content type="text"><![CDATA[static关键字主要有两种作用第一 为某特定数据类型或对象分配单一的存储空间，而与创建对象的个数无关。第二 实现某个方法或属性与类相关联。 具体用法如下： static成员变量 静态变量属于类，在内存中只有一个复制，只要静态变量所在的类被加载，这个静态变量就会被分配空间，因此就可以被使用了。两种方式分别是“类.静态变量”和”对象.静态变量”。 实例变量属于对象，只有对象被创建后，实例变量才会被分配内存空间，才能被使用，它在内存中存在多个复制，只有用“对象.实例变量”的方式来引用。 static成员方法 static方法是类的方法，不需要创建对象就可以被调用，而非static方法是对象的方法，只有对象被创建出来后才可以被使用。 static方法中不能使用this和super关键字，不能调用非static方法，只能访问所属类的静态成员变量和成员方法，static方法也不能访问非static类型的变量。因为当static方法被调用时，这个类的对象可能还没被创建，即使已经被创建了，也无法确定调用哪个对象的方法。重要用途就是单例模式的应用。 static代码块： static代码块在类中是独立于成员变量和成员函数的代码块的。 注意：这些static代码块只会被执行一次。 static内部类 OuterClassObject.new InnerClassName()，如果省略了OuterClassObject则是this. new InnerClassName(),OuterClassObject或者this指代创建这个内部类对象的一个外部类对象，是一个隐式参数，它将传入内部类的构造方法(见前所述)。但是现在这个内部类对象是由“类”直接创建的，不会产生这样的一个隐式参数传入内部类构造方法，因此内部类也就不需要“编译器自动给内部类加上一个reference，指向产生它的那个外部类的对象”，所以我们把这个内部类声明为static。 不允许在函数内部定义static变量根据上文可以得知，在Java语言中，不能在成员函数内部定义static变量，以下代码将会编译失败： class CT{public void testStatic(){ static int i=0; //编译失败 System.out.println(i++); }}]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TCP协议三次握手的过程]]></title>
      <url>%2F2016%2F01%2F23%2FTCP%E5%8D%8F%E8%AE%AE%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[TCP协议TCP(Transmission Control Protocol)传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。 三次握手TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接。 TCP报文格式TCP报文格式示意图：上图中有几个字段需要重点介绍下： （1）序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。 （2）确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=Seq+1。 （3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下： （A）URG：紧急指针（urgent pointer）有效。 （B）ACK：确认序号有效。 （C）PSH：接收方应该尽快将这个报文交给应用层。 （D）RST：重置连接。 （E）SYN：发起一个新连接。 （F）FIN：释放一个连接。 需要注意的是： （A）不要将确认序号ack与标志位中的ACK搞混了(为了区分，进行大小写，ack为序列号)。 （B）确认方Ack=发起方Seq+1，两端配对。 TCP三次握手过程TCP三次握手示意图如下： 第一次握手:客户端发送syn包 (syn=1，seq=j) 到服务器，并进入SYN_SEND状态，等待服务器确认。 第二次握手:服务器收到syn包，必须确认客户的syn（ack=j+1），同时自己也发送一个SYN包（syn=1，确认序号有效ACK=1，ack=seq+ACK，seq=k），也叫syn+ack包，此时服务器进入SYN_RECV状态。 第三次握手:客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(包括了ACK=1，ack=seq+ACK) ，此包发送完毕，服务器端收到后，确认seq值与ack=1则连接建立成功。客户端和服务器进入ESTABLISHED状态，完成三次握手，传送数据。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F01%2F18%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
